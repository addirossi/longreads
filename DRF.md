# Знакомство с API на примере DRF

Ранее мы уже познакомились с фреймворком Django и тем, как строить сайты на стороне сервера.
Теперь настало время познакомиться с иным подходом, узнать что такое REST API и с инструментом для его построения Django
Rest Framework.

До того, как начать работать с Django Rest Framework, важно ознакомиться с некоторыми понятиями.

## API

В предыдущих занятиях мы с Вами изучали Django в контексте инструмента, создающего полноценный сайт, который формирует
все страницы на стороне сервера и выдаёт уже готовые страницы клиенту. Такой подход удобен тем, что на клиентской стороне
не нужно ничего формировать: клиент отправляет запрос и получает уже готовую страницу.

Однако, у такого подхода есть и минусы. 
Давайте представим, что у Вас есть сайт, мобильные приложения для разных платформ и некое десктопное приложение. Вам 
придётся формировать на стороне сервера 4 разных варианта страниц, стили к ним, учитывать особенности платформ и т.д. 
В итоге, мы получим огромный монолит, которым очень тяжело будет управлять.

Для того, чтобы решить эту проблему и отделить клиентскую логику от серверной придумали API.

### Что такое API

**Web API (интерфейс программирования приложений для веба)** представляет собой программный интерфейс, который использует 
протокол HTTP для обмена данными и выполнения операций между веб-серверами и клиентами. Эти API позволяют веб-сервисам 
предоставлять свои функции и данные для использования другими веб-приложениями или клиентами.

Если говорить простыми словами, то у нас будет единое приложение, которое будет работать с данными и предоставлять методы
для манипуляции этими данными. А клиенты (клиентские приложения: сайты, мобильные приложения и т.д.), в свою очередь, уже
могут использовать это приложение для работы с данными.

Чаще всего используется так называемое REST API (RESTful API)

**REST API (Representational State Transfer - перенос состояния представления)** представляет собой стиль архитектуры 
программного обеспечения, используемый для построения веб-служб. REST опирается на простоту и легкость использования, а 
взаимодействие с ресурсами (например, данными или службами) происходит через стандартные HTTP-методы, такие как GET, 
POST, PUT и DELETE. Давайте рассмотрим основные принципы и элементы REST API более подробно.

1. **Ресурсы и URI (Идентификаторы ресурсов):**

REST ориентирован на ресурсы, которые представляют данные или службы. Каждый ресурс имеет свой уникальный идентификатор 
в виде URI (Uniform Resource Identifier). Например, URI может выглядеть так:
```html
https://api.example.com/users
```
где `users` - ресурс.

2. **HTTP Методы:**

REST использует стандартные HTTP-методы для выполнения операций с ресурсами:

- GET: Получение данных.
- POST: Создание нового ресурса.
- PUT: Обновление существующего ресурса.
- DELETE: Удаление ресурса.

Эти методы предоставляют единообразный интерфейс для взаимодействия с ресурсами.

3. **Представление Ресурсов:**

Ресурсы могут быть представлены в различных форматах данных, таких как `JSON` или `XML`. Клиент и сервер могут 
взаимодействовать, отправляя и получая эти представления.

4. **Состояние и Переход Состояний (HATEOAS):**

REST поддерживает идею передачи состояния представления, что означает, что сервер передает клиенту не только данные, 
но и возможные действия, которые клиент может выполнить. Это повышает гибкость клиент-серверного взаимодействия. Принцип 
HATEOAS (Hypermedia As The Engine Of Application State) акцентирует этот подход.

5. **Без состояния (Stateless):**

Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для понимания и обработки запроса. Сервер 
не должен хранить состояние между запросами от одного клиента к другому.

6. **Ограниченный Набор Операций:**

REST использует ограниченный и заранее определенный набор операций, что упрощает использование и понимание API.

И для построения RESTful API мы с Вами и будем использовать Django Rest Framework.

## Django Rest Framework

**Django Rest Framework (сокращенно DRF)** - это мощный фреймворк для создания веб-API с использованием языка 
программирования Python и фреймворка Django. Django Rest Framework обеспечивает инструменты и компоненты для удобного 
создания, тестирования и развертывания веб-сервисов.

Вот несколько ключевых характеристик Django Rest Framework:

- **Сериализация данных:** DRF предоставляет мощные средства сериализации данных, позволяя легко преобразовывать сложные 
типы данных, такие как объекты моделей, в форматы, удобные для передачи по сети, например JSON.

- **Аутентификация и авторизация:** DRF включает в себя гибкую систему аутентификации и авторизации, позволяя легко 
управлять правами доступа и безопасностью ваших API.

- **Поддержка стандартов HTTP:** DRF полностью поддерживает стандартные методы HTTP, такие как GET, POST, PUT, и DELETE. 
Он также обрабатывает обработку форм, предоставляет возможности для загрузки файлов и многое другое.

- **Представления (Views):** DRF предоставляет множество готовых представлений, которые определяют, как данные должны 
быть представлены. От простых представлений REST API до более сложных, таких как представления для работы с моделями 
Django.

- **Маршрутизация:** DRF предоставляет гибкую систему маршрутизации, которая определяет, какие URL будут обрабатываться 
как часть вашего API.

- **Валидация данных:** DRF включает в себя мощные средства для валидации данных, отправляемых и получаемых через API. 
Это включает в себя встроенные проверки, а также возможность создания пользовательских правил валидации.

Давайте знакомиться с DRF на практике:

### Установка

Установка Django Rest Framework (DRF) обычно осуществляется с использованием менеджера пакетов Python, такого как pip. 
Вот шаги, которые вы можете выполнить для установки DRF:

1. Убедитесь, что у вас установлен Django. Если его у вас нет, вы можете установить его с помощью команды:
```shell
pip install Django
```
2. После установки Django, вы можете установить Django Rest Framework:
```shell
pip install djangorestframework
```
3. После установки, добавьте приложение `rest_framework` в раздел `INSTALLED_APPS` в модуле `settings.py`:
```python
INSTALLED_APPS = [
    ...,
    'rest_framework',
]
```
4. Запустите миграции:
```shell
python manage.py migrate
```

Теперь Django Rest Framework установлен и настроен в вашем проекте. Вы можете начать создавать API, используя 
функциональность DRF для создания эндпоинтов, сериализации данных и других возможностей фреймворка.

### Создание моделей

DRF использует для работы обычные модели Django, которые уже хорошо Вам знакомы. Давайте создадим некую модель:

```python
#models.py
from django.db import models


class Product(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
```

## Сериализация данных

Как Вы уже знаете из предыдущих занятий, нам необходимо было использовать HTML-шаблоны для представления данных, чтобы
клиент мог получить их в визуально красивом формате. Но в API представление данных используется не для красоты, а для того, 
чтобы приложения, написанные на разных языках (например: API написано на Python, а клиентская часть на JavaScript), 
могли общаться друг с другом в одном формате. Таким форматом чаще всего является JSON.

Как же нам преобразовать данные из Python объектов в JSON? Для этого используются сериализаторы (serializers).

Serializer в Django Rest Framework (DRF) представляет собой механизм преобразования сложных типов данных, таких как 
объекты моделей, в форматы, удобные для передачи по сети. Сериализация в DRF включает в себя процессы преобразования 
данных в формат JSON (или другие форматы) при отправке данных от сервера к клиенту (сериализация) и обратно (десериализация).

Основные задачи сериализатора включают в себя:

1. **Преобразование объектов моделей Django в JSON:** Сериализатор позволяет легко преобразовывать объекты Django ORM в 
JSON-представление, которое может быть отправлено клиенту через API.

2. **Валидация входных данных:** При десериализации запросов, сериализатор проверяет входные данные на соответствие 
заданным правилам валидации. Это включает в себя проверку типов данных, обязательных полей и других правил.

3. **Поддержка отношений:** Сериализаторы могут автоматически обрабатывать отношения между моделями, включая вложенные 
и связанные объекты.

Давайте напишем свой сериализатор. Для этого, Вы можете использовать один из 2 классов: `Serializer` или `ModelSerializer`.

### Serializer

Класс `Serializer` в Django Rest Framework (DRF) представляет собой основной строительный блок для создания сериализаторов.
Вам необходимо наследоваться от этого класса и прописать поля, необходимые в конечном наборе данных, и их типы.

Например, нам нужно реализовать сериализатор объектов нашей модели Product. Для этого, мы создадим класс ProductSerializer,
наследованный от Serializer и определим сериализацию для полей модели:

```python
#serializers.py
from rest_framework import serializers

from app.models import Product


class ProductSerializer(serializers.Serializer):
    name = serializers.CharField(max_length=255)
    description = serializers.CharField()
    price = serializers.DecimalField(max_digits=10, decimal_places=2)
    created_at = serializers.DateTimeField()
```

Мы определили набор полей, который будут в итоговом JSON и указали типы. Как Вы видите, мы не указали 2 поля: `id` и 
`updated_at`, соответственно их не будет в выходном объекте.

Сериализация будет работать примерно так:

```python
#на входе имеем объект модели
product = Product.objects.create(...)

#передаём его в сериализатор
serializer = ProductSerializer(product)

#получаем сериализованный объект
print(serializer.data)
#{"name": "Apple IPhone 15 Pro", "description": "....", "price": 150000.00, "created_at": "2024-01-26T06:51:29.137434"}
```

Сериализацию можно реализовать ещё проще, с использованием класса ModelSerializer

### ModelSerializer

ModelSerializer в Django Rest Framework (DRF) представляет собой расширение базового класса Serializer, предназначенное 
для упрощения создания сериализаторов, связанных с моделями Django ORM. ModelSerializer автоматически генерирует поля 
для сериализации и десериализации, основываясь на модели, что делает код более кратким и поддерживаемым.

Давайте реализуем наш предыдущий сериализатор при помощи класса ModelSerializer:

```python
#serializers.py
...


class ProductSerializer(serializers.ModelSerializer):
    class Meta:
        model = Product
        fields = ["name", "description", "price", "created_at"]
```

В этом примере:

`Meta` класс определяет свойства модели, на основе которой будет создан сериализатор. Здесь `model = Product` указывает, 
что сериализатор будет связан с моделью Product. fields говорит DRF какие нужно использовать поля модели для сериализации.
Если нужно указать все поля, Вы можете указать `fields = "__all__"`.

`ModelSerializer` автоматически создает поля для каждого поля модели, обеспечивая соответствие типов данных и обработку 
валидации. Также, если у вас есть отношения в вашей модели (например, ForeignKey или ManyToManyField), ModelSerializer 
автоматически обрабатывает их, создавая вложенные сериализаторы.

## Запросы и ответы

Обработка запросов и формирование ответов реализуется view контроллерами, как и в обычном Django, но структура и логика
самих view немного отличается. Давайте рассмотрим самые распространенные варианты:

### FBV (Function-based views)

View функции в DRF в целом строятся так же, как и в обычном Django. Единственная разница состоит в том, что в DRF эти 
функции требуется оборачивать специальным декоратором `api_view`, в котором будет указываться метод запроса. А также, для
формирования ответа вместо класса HttpResponse используется класс Response.

```python
#views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response

from app.models import Product
from app.serializers import ProductSerializer


@api_view(["GET"])
def products_list(request):
    #получаем все записи из БД
    products = Product.objects.all()
    #сериализуем полученные данные, добавляем many=True, т.к. передаётся не одна запись, а несколько
    serializer = ProductSerializer(products, many=True)
    #выдаём в ответе сериализованные данные
    return Response(serializer.data)
```

В целом, логика обработки запроса строится по тем же правилам, что и в обычном Django:

1. получение данных
2. представление данных в нужном формате
3. выдача отформатированных данных в ответе

Привязка функции в urls.py полностью идентична тому, что мы применяем к обычным Django views. Может немного отличаться 
сам путь, по которому клиент выполняет запрос.

```python
# urls.py
from django.urls import path

from app.views import products_list

urlpatterns = [
    ..., 
    path("api/v1/products/", products_list)
]
```

### CBV (Class-based views)

Использование классов представлений в DRF также очень похоже на то, что мы делаем в обычном Django, более того, базовый 
класс представлений DRF `APIView` является дочерним классом джанговского класса View.

Логика работы следующая:

- нам необходимо наследоваться от класса APIView
- в самом классе нужно будет реализовать метод с названием, идентичным методу запроса

`GET -> def get(...)`

`POST -> def post(...)`

`PATCH -> def patch()`

и т.д.

- внутри метода реализовать логику обработки запроса.

Например, функцию выше можно переписать как:

```python
from rest_framework.views import APIView


class ProductsListView(APIView):
    def get(self, request):
        #получаем все записи из БД
        products = Product.objects.all()
        #сериализуем полученные данные, добавляем many=True, т.к. передаётся не одна запись, а несколько
        serializer = ProductSerializer(products, many=True)
        #выдаём в ответе сериализованные данные
        return Response(serializer.data)
```

Привязка urls также будет идентична джанговской

```python
...
from app.views import ProductsListView


urlpatterns = [
    ...,
    path("api/v1/products/", ProductsListView.as_view())
]
```

Помимо функций и класса APIView DRF предоставляет ещё некоторые варианты построения представлений, которые мы рассмотрим
на следующих занятиях.

